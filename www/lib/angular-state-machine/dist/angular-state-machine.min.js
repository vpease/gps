/**
 * AngularJS service to implement a finite state machine.
 * @version v1.0.0 - 2015-02-07
 * @link https://github.com/tafax/angular-state-machine
 * @author Matteo Tafani Alunno <matteo.tafanialunno@gmail.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
"use strict";function MachineConfiguration(a){var b={},c=[],d={};this.getStates=function(){return b},this.getMessages=function(){return c},this.getTransitions=function(){return d},this.extend=function(b){a=Object.merge(a,b)},this.configure=function(){if(!a.hasOwnProperty("init"))throw"You have to create 'init' state.";for(var e in a)if(a.hasOwnProperty(e)){var f=a[e];f.name=e;var g={};if(f.hasOwnProperty("transitions")){g=f.transitions;for(var h in g)g.hasOwnProperty(h)&&c.indexOf(h)<0&&c.push(h);delete f.transitions}d.hasOwnProperty(e)||(d[e]={}),angular.extend(d[e],g),b.hasOwnProperty(e)||(b[e]={}),angular.extend(b[e],f)}}}function StateMachine(a,b,c){this.initialize=function(){b.initialize(c)},this.getStates=function(){return b.getStates(c)},this.getMessages=function(){return b.getMessages(c)},this.hasMessage=function(a){return b.hasMessage(c,a)},this.isAvailable=function(a){return b.isAvailable(c,a)},this.available=function(){return b.available(c)},this.send=function(d,e){b.send(a,c,d,e)}}function MachineStrategy(){}function SyncStrategy(){MachineStrategy.call(this),this.current=null}Object.merge=function(a,b){var c={};for(var d in a)c[d]=a[d],d in b&&"object"==typeof a[d]&&null!==d&&(c[d]=Object.merge(a[d],b[d]));for(var e in b)e in c||(c[e]=b[e]);return c};var FSM=angular.module("FSM",[]);FSM.provider("stateMachine",function(){var a;this.config=function(b){a=b},this.$get=["$injector",function(b){return new StateMachine(b,new SyncStrategy,new MachineConfiguration(a))}]}),MachineStrategy.prototype.initialize=function(){},MachineStrategy.prototype.getStates=function(){},MachineStrategy.prototype.getMessages=function(){},MachineStrategy.prototype.hasMessage=function(){},MachineStrategy.prototype.isAvailable=function(){},MachineStrategy.prototype.available=function(){},MachineStrategy.prototype.send=function(){},MachineStrategy.prototype=new MachineStrategy,SyncStrategy.prototype.initialize=function(a){a.configure();var b=a.getStates();this.current=b.init,this.current.params={}},SyncStrategy.prototype.getStates=function(a){return Object.keys(a.getStates())},SyncStrategy.prototype.getMessages=function(a){return a.getMessages()},SyncStrategy.prototype.hasMessage=function(a,b){var c=a.getMessages();return c.indexOf(b)>=0},SyncStrategy.prototype.isAvailable=function(a,b){var c=a.getTransitions(),d=c[this.current.name];return d.hasOwnProperty(b)},SyncStrategy.prototype.available=function(a){var b=a.getTransitions(),c=b[this.current.name];return Object.keys(c)},SyncStrategy.prototype.send=function(a,b,c,d){if(this.hasMessage(b,c)&&this.isAvailable(b,c)){var e=b.getTransitions(),f=e[this.current.name],g=f[c];if(g instanceof Array){var h=[];for(var i in g){var j=g[i];a.invoke(j.predicate,this,this.current)&&h.push(j.to)}if(h.length>1)throw"Unable to execute transition in state '"+this.current.name+"'. More than one predicate is passed.";g=h[0]}var k=b.getStates(),l=k[g],m={};m=Object.merge(m,this.current),delete m.action,d&&(m.params=Object.merge(m.params,d));var n=a.invoke(l.action,this,m);!n&&this.current.params?l.params=this.current.params:(l.hasOwnProperty("params")||(l.params={}),l.params=Object.merge(l.params,n)),this.current=l}};